Copyright 2024-2025 The Trivalent Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
---
diff --git a/content/common/gpu_pre_sandbox_hook_linux.cc b/content/common/gpu_pre_sandbox_hook_linux.cc
index 2e53794fa3..986d44ab5d 100644
--- a/content/common/gpu_pre_sandbox_hook_linux.cc
+++ b/content/common/gpu_pre_sandbox_hook_linux.cc
@@ -48,8 +48,8 @@ using sandbox::syscall_broker::BrokerProcess;
 namespace content {
 namespace {
 
-inline bool IsChromeOS() {
-#if BUILDFLAG(IS_CHROMEOS)
+inline bool IsLinux() {
+#if BUILDFLAG(IS_LINUX)
   return true;
 #else
   return false;
@@ -86,7 +86,7 @@ inline bool UseV4L2Codec(
 static const char kMaliConfPath[] = "/etc/mali_platform.conf";
 #endif
 
-#if BUILDFLAG(IS_CHROMEOS) && defined(__aarch64__)
+#if defined(__aarch64__)
 static const char kLibGlesPath[] = "/usr/lib64/libGLESv2.so.2";
 static const char kLibEglPath[] = "/usr/lib64/libEGL.so.1";
 static const char kLibMaliPath[] = "/usr/lib64/libmali.so";
@@ -100,7 +100,7 @@ static const char kLibTegraPath[] = "/usr/lib/libtegrav4l2.so";
 
 constexpr int dlopen_flag = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
 
-void AddStandardChromeOsPermissions(
+void AddStandardLinuxPermissions(
     std::vector<BrokerFilePermission>* permissions) {
   // For the ANGLE passthrough command decoder.
   static const char* const kReadOnlyList[] = {"libEGL.so", "libGLESv2.so"};
@@ -115,6 +115,18 @@ void AddStandardChromeOsPermissions(
   }
 }
 
+void AddLibGalliumLinuxPermissions(
+    std::vector<BrokerFilePermission>* permissions,
+    const std::string driver_version) {
+  if (driver_version.empty()) {
+    LOG(ERROR) << "Detected driver version is empty, gpu sandbox may fail";
+    return;
+  }
+  const std::string libgallium_path =
+             "/usr/lib64/libgallium-" + driver_version + ".so";
+  LOG(ERROR) << "Detected gallium path : " << libgallium_path;
+  permissions->push_back(BrokerFilePermission::ReadOnly(libgallium_path));
+}
 void AddV4L2GpuPermissions(
     std::vector<BrokerFilePermission>* permissions,
     const sandbox::policy::SandboxSeccompBPF::Options& options) {
@@ -257,6 +269,11 @@ void AddAmdGpuPermissions(std::vector<BrokerFilePermission>* permissions) {
       // that requires the following libs and files to be accessible.
       "/usr/lib64/libEGL.so.1",
       "/usr/lib64/libGLESv2.so.2",
+#if !BUILDFLAG(IS_CHROMEOS) // Linux AMD
+      "/usr/lib64/libwayland-server.so.0",
+      "/usr/lib64/gbm/dri_gbm.so",
+      "/usr/lib64/dri/iHD_drv_video.so",
+#endif
       "/usr/lib64/libglapi.so.0",
       "/usr/lib64/libgallium_dri.so",
       "/usr/lib64/dri/r300_dri.so",
@@ -298,6 +315,9 @@ void AddNvidiaGpuPermissions(std::vector<BrokerFilePermission>* permissions) {
       // that requires the following libs and files to be accessible.
       "/etc/ld.so.cache",
       "/usr/lib64/libgallium_dri.so",
+#if !BUILDFLAG(IS_CHROMEOS) // Linux Nvidia
+      "/usr/lib64/gbm/dri_gbm.so",
+#endif
       "/usr/lib64/dri/nouveau_dri.so",
       "/usr/lib64/dri/radeonsi_dri.so",
       "/usr/lib64/dri/swrast_dri.so",
@@ -324,6 +344,10 @@ void AddIntelGpuPermissions(std::vector<BrokerFilePermission>* permissions) {
       // To support threads in mesa we use --gpu-sandbox-start-early and
       // that requires the following libs and files to be accessible.
       "/usr/lib64/libgallium_dri.so",
+#if !BUILDFLAG(IS_CHROMEOS) // Linux Intel
+      "/usr/lib64/gbm/dri_gbm.so",
+      "/usr/lib64/dri/iHD_drv_video.so",
+#endif
       "/usr/lib64/libEGL.so.1", "/usr/lib64/libGLESv2.so.2",
       "/usr/lib64/libelf.so.1", "/usr/lib64/libglapi.so.0",
       "/usr/lib64/libdrm_amdgpu.so.1", "/usr/lib64/libdrm_radeon.so.1",
@@ -363,6 +387,11 @@ void AddVirtIOGpuPermissions(std::vector<BrokerFilePermission>* permissions) {
       "/usr/lib64/libglapi.so.0",
       "/usr/lib64/libc++.so.1",
       "/usr/lib64/libgallium_dri.so",
+#if !BUILDFLAG(IS_CHROMEOS) // Linux VirtIO
+      "/usr/lib64/dri/virtio_gpu_drv_video.so",
+      "/usr/lib64/libwayland-server.so.0",
+      "/usr/lib64/gbm/dri_gbm.so",
+#endif
       // If kms_swrast_dri is not usable, swrast_dri is used instead.
       "/usr/lib64/dri/swrast_dri.so",
       "/usr/lib64/dri/kms_swrast_dri.so",
@@ -548,11 +577,13 @@ void LoadArmGpuLibraries() {
 }
 
 bool LoadAmdGpuLibraries() {
+#if BUILDFLAG(IS_CHROMEOS)
   // Preload the amdgpu-dependent libraries.
   if (nullptr == dlopen("libglapi.so", dlopen_flag)) {
     LOG(ERROR) << "dlopen(libglapi.so) failed with error: " << dlerror();
     return false;
   }
+#endif // IS_CHROMEOS
 
   const char* radeonsi_lib = "/usr/lib64/dri/radeonsi_dri.so";
 #if defined(DRI_DRIVER_DIR)
@@ -609,7 +640,7 @@ sandbox::syscall_broker::BrokerCommandSet CommandSetForGPU(
   command_set.set(sandbox::syscall_broker::COMMAND_ACCESS);
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
   command_set.set(sandbox::syscall_broker::COMMAND_STAT);
-  if (IsChromeOS() &&
+  if (IsLinux() &&
       (options.use_amd_specific_policies ||
        options.use_intel_specific_policies ||
        options.use_nvidia_specific_policies ||
@@ -628,9 +659,9 @@ std::vector<BrokerFilePermission> FilePermissionsForGpu(
 
   AddVulkanICDPermissions(&permissions);
 
-  if (IsChromeOS()) {
+  if (IsLinux()) {
     // Permissions are additive, there can be multiple GPUs in the system.
-    AddStandardChromeOsPermissions(&permissions);
+    AddStandardLinuxPermissions(&permissions);
     if (UseV4L2Codec(options)) {
       AddV4L2GpuPermissions(&permissions, options);
     }
@@ -643,9 +674,11 @@ std::vector<BrokerFilePermission> FilePermissionsForGpu(
     }
     if (options.use_amd_specific_policies) {
       AddAmdGpuPermissions(&permissions);
+      AddLibGalliumLinuxPermissions(&permissions, options.driver_version);
     }
     if (options.use_intel_specific_policies) {
       AddIntelGpuPermissions(&permissions);
+      AddLibGalliumLinuxPermissions(&permissions, options.driver_version);
     }
     if (options.use_nvidia_specific_policies) {
       AddStandardGpuPermissions(&permissions);
@@ -678,7 +711,7 @@ bool LoadLibrariesForGpu(
   if (IsArchitectureArm()) {
     LoadArmGpuLibraries();
   }
-  if (IsChromeOS()) {
+  if (IsLinux()) {
     if (options.use_amd_specific_policies) {
       if (!LoadAmdGpuLibraries())
         return false;
diff --git a/content/gpu/gpu_main.cc b/content/gpu/gpu_main.cc
index 30cc1d4a17..a565ea4b5c 100644
--- a/content/gpu/gpu_main.cc
+++ b/content/gpu/gpu_main.cc
@@ -527,6 +527,7 @@ bool StartSandboxLinux(gpu::GpuWatchdogThread* watchdog_thread,
       else if (angle::IsNVIDIA(gpu.vendor_id))
         sandbox_options.use_nvidia_specific_policies = true;
     }
+    sandbox_options.driver_version = gpu_prefs.gallium_version;
   }
   sandbox_options.accelerated_video_decode_enabled =
       !gpu_prefs.disable_accelerated_video_decode;
diff --git a/content/public/browser/gpu_utils.cc b/content/public/browser/gpu_utils.cc
index 65dea86a65..ab9d387a01 100644
--- a/content/public/browser/gpu_utils.cc
+++ b/content/public/browser/gpu_utils.cc
@@ -29,6 +29,10 @@
 #include "ui/gfx/switches.h"
 #include "ui/gl/gl_features.h"
 
+#if BUILDFLAG(IS_LINUX)
+#include "third_party/re2/src/re2/re2.h"
+#endif
+
 namespace {
 
 void KillGpuProcessImpl(content::GpuProcessHost* host) {
@@ -82,6 +86,25 @@ const gpu::GpuPreferences GetGpuPreferencesFromCommandLine() {
   gpu_preferences.gpu_sandbox_start_early =
       command_line->HasSwitch(switches::kGpuSandboxStartEarly);
 
+  gpu_preferences.gpu_sandbox_linux =
+#if BUILDFLAG(IS_LINUX)
+      command_line->HasSwitch("enable-gpu-sandbox-linux") &&
+      command_line->HasSwitch("ozone-platform") &&
+      command_line->GetSwitchValueASCII("ozone-platform") == "wayland";
+#else
+      false;
+#endif
+
+#if BUILDFLAG(IS_LINUX)
+  if (command_line->HasSwitch("libgallium-version")) {
+    const std::string libgalliumVersion =
+          command_line->GetSwitchValueASCII("libgallium-version");
+    // We may recieve untrusted input, so validate it matches a version format
+    if (RE2::FullMatch(libgalliumVersion, "[1-9][0-9]+\\.[0-9]\\.[0-9]"))
+      gpu_preferences.gallium_version = libgalliumVersion;
+  }
+#endif
+
   gpu_preferences.enable_vulkan_protected_memory =
       command_line->HasSwitch(switches::kEnableVulkanProtectedMemory);
   gpu_preferences.disable_vulkan_fallback_to_gl_for_testing =
diff --git a/gpu/config/gpu_preferences.h b/gpu/config/gpu_preferences.h
index 7da57a4b42..e9e7fa3df2 100644
--- a/gpu/config/gpu_preferences.h
+++ b/gpu/config/gpu_preferences.h
@@ -134,6 +134,12 @@ struct GPU_CONFIG_EXPORT GpuPreferences {
   // Starts the GPU sandbox before creating a GL context.
   bool gpu_sandbox_start_early = false;
 
+  // LibGallium library version for sandbox whitelist.
+  std::string gallium_version;
+
+  // Enable the GPU sandbox on Linux, implies gpu_sandbox_start_early
+  bool gpu_sandbox_linux = false;
+
   // Enables using CODECAPI_AVLowLatencyMode. Windows only.
   bool enable_low_latency_dxva = true;
 
diff --git a/gpu/ipc/common/gpu_preferences.mojom b/gpu/ipc/common/gpu_preferences.mojom
index 9cc16eaa45..3e221581bf 100644
--- a/gpu/ipc/common/gpu_preferences.mojom
+++ b/gpu/ipc/common/gpu_preferences.mojom
@@ -59,6 +59,8 @@ struct GpuPreferences {
   bool gpu_startup_dialog;
   bool disable_gpu_watchdog;
   bool gpu_sandbox_start_early;
+  bool gpu_sandbox_linux;
+  string gallium_version;
 
   // TODO(http://crbug.com/676224) Support preprocessing of mojoms. Following
   // variables should be used on Windows only.
diff --git a/gpu/ipc/common/gpu_preferences_mojom_traits.h b/gpu/ipc/common/gpu_preferences_mojom_traits.h
index 28d9ac5174..f621437301 100644
--- a/gpu/ipc/common/gpu_preferences_mojom_traits.h
+++ b/gpu/ipc/common/gpu_preferences_mojom_traits.h
@@ -221,6 +221,9 @@ struct GPU_IPC_COMMON_EXPORT StructTraits<gpu::mojom::GpuPreferencesDataView,
     out->gpu_startup_dialog = prefs.gpu_startup_dialog();
     out->disable_gpu_watchdog = prefs.disable_gpu_watchdog();
     out->gpu_sandbox_start_early = prefs.gpu_sandbox_start_early();
+    out->gpu_sandbox_linux = prefs.gpu_sandbox_linux();
+    if (!prefs.ReadGalliumVersion(&out->gallium_version))
+      return false;
     out->enable_low_latency_dxva = prefs.enable_low_latency_dxva();
     out->enable_zero_copy_dxgi_video = prefs.enable_zero_copy_dxgi_video();
     out->enable_nv12_dxgi_video = prefs.enable_nv12_dxgi_video();
@@ -325,6 +328,12 @@ struct GPU_IPC_COMMON_EXPORT StructTraits<gpu::mojom::GpuPreferencesDataView,
   static bool gpu_sandbox_start_early(const gpu::GpuPreferences& prefs) {
     return prefs.gpu_sandbox_start_early;
   }
+  static bool gpu_sandbox_linux(const gpu::GpuPreferences& prefs) {
+    return prefs.gpu_sandbox_linux;
+  }
+  static const std::string& gallium_version(const gpu::GpuPreferences& prefs) {
+    return prefs.gallium_version;
+  }
   static bool enable_low_latency_dxva(const gpu::GpuPreferences& prefs) {
     return prefs.enable_low_latency_dxva;
   }
diff --git a/gpu/ipc/service/gpu_init.cc b/gpu/ipc/service/gpu_init.cc
index 6ea960c6f8..a22bc31453 100644
--- a/gpu/ipc/service/gpu_init.cc
+++ b/gpu/ipc/service/gpu_init.cc
@@ -54,6 +54,10 @@
 #include <GLES2/gl2.h>
 #endif
 
+#if BUILDFLAG(IS_LINUX)
+#include "third_party/angle/src/gpu_info_util/SystemInfo.h"
+#endif
+
 #if BUILDFLAG(IS_OZONE)
 #include "gpu/command_buffer/service/drm_modifiers_filter_vulkan.h"
 #include "ui/ozone/public/drm_modifiers_filter.h"
@@ -352,6 +356,14 @@ GpuInit::~GpuInit() {
   StopForceDiscreteGPU();
 }
 
+// TODO: Add the following
+//angle::IsNVIDIA(vendor_id)
+//angle::IsVirtIO(vendor_id)
+//angle::IsARM(vendor_id)
+bool IsGpuSandboxSupportedPlatform(uint32_t vendor_id) {
+  return angle::IsAMD(vendor_id) || angle::IsIntel(vendor_id);
+}
+
 bool GpuInit::InitializeAndStartSandbox(base::CommandLine* command_line,
                                         const GpuPreferences& gpu_preferences) {
   TRACE_EVENT("gpu,startup", "gpu::GpuInit::InitializeAndStartSandbox");
@@ -418,8 +430,21 @@ bool GpuInit::InitializeAndStartSandbox(base::CommandLine* command_line,
   enable_watchdog = false;
 #endif
 
+  bool gpu_sandbox_linux = gpu_preferences_.gpu_sandbox_linux;
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-  bool gpu_sandbox_start_early = gpu_preferences_.gpu_sandbox_start_early;
+  // Only enable on platforms where the sandbox works
+  if (gpu_sandbox_linux &&
+      IsGpuSandboxSupportedPlatform(gpu_info_.active_gpu().vendor_id)) {
+    for (const auto& gpu : gpu_info_.secondary_gpus) {
+      if (!IsGpuSandboxSupportedPlatform(gpu.vendor_id)) {
+        gpu_sandbox_linux = false;
+        break;
+      }
+    }
+  }
+  bool gpu_sandbox_start_early = gpu_preferences_.gpu_sandbox_start_early ||
+      // The sandbox does not work with Vulkan currently
+      (gpu_sandbox_linux && !features::IsUsingVulkan());
 #else   // !(BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS))
   // For some reasons MacOSX's VideoToolbox might crash when called after
   // initializing GL, see crbug.com/1047643 and crbug.com/871280. On other
@@ -460,7 +485,7 @@ bool GpuInit::InitializeAndStartSandbox(base::CommandLine* command_line,
   // On Chrome OS ARM Mali, GPU driver userspace creates threads when
   // initializing a GL context, so start the sandbox early.
   // TODO(zmo): Need to collect OS version before this.
-  if (gpu_preferences_.gpu_sandbox_start_early) {
+  if (gpu_sandbox_start_early) {
     gpu_info_.sandboxed = sandbox_helper_->EnsureSandboxInitialized(
         watchdog_thread_.get(), &gpu_info_, gpu_preferences_);
     attempted_startsandbox = true;
diff --git a/sandbox/policy/linux/sandbox_seccomp_bpf_linux.cc b/sandbox/policy/linux/sandbox_seccomp_bpf_linux.cc
index 4de13fe88b..aaebda0773 100644
--- a/sandbox/policy/linux/sandbox_seccomp_bpf_linux.cc
+++ b/sandbox/policy/linux/sandbox_seccomp_bpf_linux.cc
@@ -94,8 +94,8 @@ namespace {
 // nacl_helper needs to be tiny and includes only part of content/
 // in its dependencies. Make sure to not link things that are not needed.
 #if !defined(IN_NACL_HELPER)
-inline bool IsChromeOS() {
-#if BUILDFLAG(IS_CHROMEOS)
+inline bool IsLinux() {
+#if BUILDFLAG(IS_LINUX)
   return true;
 #else
   return false;
@@ -121,7 +121,7 @@ inline bool IsArchitectureArm() {
 std::unique_ptr<BPFBasePolicy> GetGpuProcessSandbox(
     const SandboxSeccompBPF::Options& options,
     MremapPolicy mremap_policy) {
-  if (IsChromeOS() || UseChromecastSandboxAllowlist()) {
+  if (IsLinux() || UseChromecastSandboxAllowlist()) {
     if (IsArchitectureArm()) {
       return std::make_unique<CrosArmGpuProcessPolicy>(
           mremap_policy, base::CommandLine::ForCurrentProcess()->HasSwitch(
diff --git a/sandbox/policy/linux/sandbox_seccomp_bpf_linux.h b/sandbox/policy/linux/sandbox_seccomp_bpf_linux.h
index 165ca85462..1c6fdeaa88 100644
--- a/sandbox/policy/linux/sandbox_seccomp_bpf_linux.h
+++ b/sandbox/policy/linux/sandbox_seccomp_bpf_linux.h
@@ -33,6 +33,7 @@ class SANDBOX_POLICY_EXPORT SandboxSeccompBPF {
     // Options for GPU's PreSandboxHook.
     bool accelerated_video_decode_enabled = false;
     bool accelerated_video_encode_enabled = false;
+    std::string driver_version;
   };
 
   SandboxSeccompBPF() = delete;

Copyright 2024-2025 The Trivalent Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
---
--- a/content/common/gpu_pre_sandbox_hook_linux.cc
+++ b/content/common/gpu_pre_sandbox_hook_linux.cc
@@ -48,8 +48,8 @@
 namespace content {
 namespace {
 
-inline bool IsChromeOS() {
-#if BUILDFLAG(IS_CHROMEOS)
+inline bool IsLinux() {
+#if BUILDFLAG(IS_LINUX)
   return true;
 #else
   return false;
@@ -92,15 +92,15 @@
 static const char kLibMaliPath[] = "/usr/lib64/libmali.so";
 static const char kLibTegraPath[] = "/usr/lib64/libtegrav4l2.so";
 #else
-static const char kLibGlesPath[] = "/usr/lib/libGLESv2.so.2";
-static const char kLibEglPath[] = "/usr/lib/libEGL.so.1";
-static const char kLibMaliPath[] = "/usr/lib/libmali.so";
-static const char kLibTegraPath[] = "/usr/lib/libtegrav4l2.so";
+static const char kLibGlesPath[] = "/usr/lib/x86_64-linux-gnu/libGLESv2.so.2";
+static const char kLibEglPath[] = "/usr/lib/x86_64-linux-gnu/libEGL.so.1";
+static const char kLibMaliPath[] = "/usr/lib/x86_64-linux-gnu/libmali.so";
+static const char kLibTegraPath[] = "/usr/lib/x86_64-linux-gnu/libtegrav4l2.so";
 #endif
 
 constexpr int dlopen_flag = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
 
-void AddStandardChromeOsPermissions(
+void AddStandardLinuxPermissions(
     std::vector<BrokerFilePermission>* permissions) {
   // For the ANGLE passthrough command decoder.
   static const char* const kReadOnlyList[] = {"libEGL.so", "libGLESv2.so"};
@@ -115,6 +115,18 @@
   }
 }
 
+void AddLibGalliumLinuxPermissions(
+    std::vector<BrokerFilePermission>* permissions,
+    const std::string driver_version) {
+  if (driver_version.empty()) {
+    LOG(ERROR) << "Detected driver version is empty, gpu sandbox may fail";
+    return;
+  }
+  const std::string libgallium_path =
+             "/usr/lib/x86_64-linux-gnu/libgallium-" + driver_version + ".so";
+  LOG(ERROR) << "Detected gallium path : " << libgallium_path;
+  permissions->push_back(BrokerFilePermission::ReadOnly(libgallium_path));
+}
 void AddV4L2GpuPermissions(
     std::vector<BrokerFilePermission>* permissions,
     const sandbox::policy::SandboxSeccompBPF::Options& options) {
@@ -255,18 +267,23 @@
       "/etc/ld.so.cache",
       // To support threads in mesa we use --gpu-sandbox-start-early and
       // that requires the following libs and files to be accessible.
-      "/usr/lib64/libEGL.so.1",
-      "/usr/lib64/libGLESv2.so.2",
-      "/usr/lib64/libglapi.so.0",
-      "/usr/lib64/libgallium_dri.so",
-      "/usr/lib64/dri/r300_dri.so",
-      "/usr/lib64/dri/r600_dri.so",
-      "/usr/lib64/dri/radeonsi_dri.so",
+      "/usr/lib/x86_64-linux-gnu/libEGL.so.1",
+      "/usr/lib/x86_64-linux-gnu/libGLESv2.so.2",
+#if !BUILDFLAG(IS_CHROMEOS)  // Linux AMD
+      "/usr/lib/x86_64-linux-gnu/libwayland-server.so.0",
+      "/usr/lib/x86_64-linux-gnu/gbm/dri_gbm.so",
+      "/usr/lib/x86_64-linux-gnu/dri/iHD_drv_video.so",
+#endif
+      "/usr/lib/x86_64-linux-gnu/libglapi.so.0",
+      "/usr/lib/x86_64-linux-gnu/libgallium_dri.so",
+      "/usr/lib/x86_64-linux-gnu/dri/r300_dri.so",
+      "/usr/lib/x86_64-linux-gnu/dri/r600_dri.so",
+      "/usr/lib/x86_64-linux-gnu/dri/radeonsi_dri.so",
       // Allow libglvnd files and libs.
       "/usr/share/glvnd/egl_vendor.d",
       "/usr/share/glvnd/egl_vendor.d/50_mesa.json",
-      "/usr/lib64/libEGL_mesa.so.0",
-      "/usr/lib64/libGLdispatch.so.0"};
+      "/usr/lib/x86_64-linux-gnu/libEGL_mesa.so.0",
+      "/usr/lib/x86_64-linux-gnu/libGLdispatch.so.0"};
   for (const char* item : kReadOnlyList)
     permissions->push_back(BrokerFilePermission::ReadOnly(item));
 
@@ -297,19 +314,22 @@
       // To support threads in mesa we use --gpu-sandbox-start-early and
       // that requires the following libs and files to be accessible.
       "/etc/ld.so.cache",
-      "/usr/lib64/libgallium_dri.so",
-      "/usr/lib64/dri/nouveau_dri.so",
-      "/usr/lib64/dri/radeonsi_dri.so",
-      "/usr/lib64/dri/swrast_dri.so",
-      "/usr/lib64/libEGL.so.1",
-      "/usr/lib64/libEGL_mesa.so.0",
-      "/usr/lib64/libGLESv2.so.2",
-      "/usr/lib64/libGLdispatch.so.0",
-      "/usr/lib64/libdrm_amdgpu.so.1",
-      "/usr/lib64/libdrm_nouveau.so.2",
-      "/usr/lib64/libdrm_radeon.so.1",
-      "/usr/lib64/libelf.so.1",
-      "/usr/lib64/libglapi.so.0",
+      "/usr/lib/x86_64-linux-gnu/libgallium_dri.so",
+#if !BUILDFLAG(IS_CHROMEOS)  // Linux Nvidia
+      "/usr/lib/x86_64-linux-gnu/gbm/dri_gbm.so",
+#endif
+      "/usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so",
+      "/usr/lib/x86_64-linux-gnu/dri/radeonsi_dri.so",
+      "/usr/lib/x86_64-linux-gnu/dri/swrast_dri.so",
+      "/usr/lib/x86_64-linux-gnu/libEGL.so.1",
+      "/usr/lib/x86_64-linux-gnu/libEGL_mesa.so.0",
+      "/usr/lib/x86_64-linux-gnu/libGLESv2.so.2",
+      "/usr/lib/x86_64-linux-gnu/libGLdispatch.so.0",
+      "/usr/lib/x86_64-linux-gnu/libdrm_amdgpu.so.1",
+      "/usr/lib/x86_64-linux-gnu/libdrm_nouveau.so.2",
+      "/usr/lib/x86_64-linux-gnu/libdrm_radeon.so.1",
+      "/usr/lib/x86_64-linux-gnu/libelf.so.1",
+      "/usr/lib/x86_64-linux-gnu/libglapi.so.0",
       "/usr/share/glvnd/egl_vendor.d",
       "/usr/share/glvnd/egl_vendor.d/50_mesa.json"};
   for (const char* item : kReadOnlyList) {
@@ -323,20 +343,24 @@
   static const char* const kReadOnlyList[] = {
       // To support threads in mesa we use --gpu-sandbox-start-early and
       // that requires the following libs and files to be accessible.
-      "/usr/lib64/libgallium_dri.so",
-      "/usr/lib64/libEGL.so.1", "/usr/lib64/libGLESv2.so.2",
-      "/usr/lib64/libelf.so.1", "/usr/lib64/libglapi.so.0",
-      "/usr/lib64/libdrm_amdgpu.so.1", "/usr/lib64/libdrm_radeon.so.1",
-      "/usr/lib64/libdrm_nouveau.so.2", "/usr/lib64/dri/crocus_dri.so",
-      "/usr/lib64/dri/i965_dri.so", "/usr/lib64/dri/iris_dri.so",
-      "/usr/lib64/dri/swrast_dri.so", "/usr/lib64/libzstd.so.1",
+      "/usr/lib/x86_64-linux-gnu/libgallium_dri.so",
+#if !BUILDFLAG(IS_CHROMEOS)  // Linux Intel
+      "/usr/lib/x86_64-linux-gnu/gbm/dri_gbm.so",
+      "/usr/lib/x86_64-linux-gnu/dri/iHD_drv_video.so",
+#endif
+      "/usr/lib/x86_64-linux-gnu/libEGL.so.1", "/usr/lib/x86_64-linux-gnu/libGLESv2.so.2",
+      "/usr/lib/x86_64-linux-gnu/libelf.so.1", "/usr/lib/x86_64-linux-gnu/libglapi.so.0",
+      "/usr/lib/x86_64-linux-gnu/libdrm_amdgpu.so.1", "/usr/lib/x86_64-linux-gnu/libdrm_radeon.so.1",
+      "/usr/lib/x86_64-linux-gnu/libdrm_nouveau.so.2", "/usr/lib/x86_64-linux-gnu/dri/crocus_dri.so",
+      "/usr/lib/x86_64-linux-gnu/dri/i965_dri.so", "/usr/lib/x86_64-linux-gnu/dri/iris_dri.so",
+      "/usr/lib/x86_64-linux-gnu/dri/swrast_dri.so", "/usr/lib/x86_64-linux-gnu/libzstd.so.1",
       // Allow libglvnd files and libs.
       "/usr/share/glvnd/egl_vendor.d",
       "/usr/share/glvnd/egl_vendor.d/50_mesa.json",
-      "/usr/lib64/libEGL_mesa.so.0", "/usr/lib64/libGLdispatch.so.0",
+      "/usr/lib/x86_64-linux-gnu/libEGL_mesa.so.0", "/usr/lib/x86_64-linux-gnu/libGLdispatch.so.0",
       // Case of when the only libc++abi.so.1 is preloaded.
       // See: crbug.com/1366646
-      "/usr/lib64/libc++.so.1"};
+      "/usr/lib/x86_64-linux-gnu/libc++.so.1"};
   for (const char* item : kReadOnlyList)
     permissions->push_back(BrokerFilePermission::ReadOnly(item));
 
@@ -352,21 +376,26 @@
       // to use kms_swrast.
       "/sys",
       "/sys/dev",
-      "/usr/lib64/libdrm_amdgpu.so.1",
-      "/usr/lib64/libdrm_radeon.so.1",
-      "/usr/lib64/libdrm_nouveau.so.2",
-      "/usr/lib64/libelf.so.1",
-      "/usr/lib64/libEGL.so.1",
-      "/usr/lib64/libGLESv2.so.2",
-      "/usr/lib64/libEGL_mesa.so.0",
-      "/usr/lib64/libGLdispatch.so.0",
-      "/usr/lib64/libglapi.so.0",
-      "/usr/lib64/libc++.so.1",
-      "/usr/lib64/libgallium_dri.so",
+      "/usr/lib/x86_64-linux-gnu/libdrm_amdgpu.so.1",
+      "/usr/lib/x86_64-linux-gnu/libdrm_radeon.so.1",
+      "/usr/lib/x86_64-linux-gnu/libdrm_nouveau.so.2",
+      "/usr/lib/x86_64-linux-gnu/libelf.so.1",
+      "/usr/lib/x86_64-linux-gnu/libEGL.so.1",
+      "/usr/lib/x86_64-linux-gnu/libGLESv2.so.2",
+      "/usr/lib/x86_64-linux-gnu/libEGL_mesa.so.0",
+      "/usr/lib/x86_64-linux-gnu/libGLdispatch.so.0",
+      "/usr/lib/x86_64-linux-gnu/libglapi.so.0",
+      "/usr/lib/x86_64-linux-gnu/libc++.so.1",
+      "/usr/lib/x86_64-linux-gnu/libgallium_dri.so",
+#if !BUILDFLAG(IS_CHROMEOS)  // Linux VirtIO
+      "/usr/lib/x86_64-linux-gnu/dri/virtio_gpu_drv_video.so",
+      "/usr/lib/x86_64-linux-gnu/libwayland-server.so.0",
+      "/usr/lib/x86_64-linux-gnu/gbm/dri_gbm.so",
+#endif
       // If kms_swrast_dri is not usable, swrast_dri is used instead.
-      "/usr/lib64/dri/swrast_dri.so",
-      "/usr/lib64/dri/kms_swrast_dri.so",
-      "/usr/lib64/dri/virtio_gpu_dri.so",
+      "/usr/lib/x86_64-linux-gnu/dri/swrast_dri.so",
+      "/usr/lib/x86_64-linux-gnu/dri/kms_swrast_dri.so",
+      "/usr/lib/x86_64-linux-gnu/dri/virtio_gpu_dri.so",
       "/usr/share/glvnd/egl_vendor.d",
       "/usr/share/glvnd/egl_vendor.d/50_mesa.json",
   };
@@ -548,13 +577,15 @@
 }
 
 bool LoadAmdGpuLibraries() {
+#if BUILDFLAG(IS_CHROMEOS)
   // Preload the amdgpu-dependent libraries.
   if (nullptr == dlopen("libglapi.so", dlopen_flag)) {
     LOG(ERROR) << "dlopen(libglapi.so) failed with error: " << dlerror();
     return false;
   }
+#endif // IS_CHROMEOS
 
-  const char* radeonsi_lib = "/usr/lib64/dri/radeonsi_dri.so";
+  const char* radeonsi_lib = "/usr/lib/x86_64-linux-gnu/dri/radeonsi_dri.so";
 #if defined(DRI_DRIVER_DIR)
   radeonsi_lib = DRI_DRIVER_DIR "/radeonsi_dri.so";
 #endif
@@ -609,7 +640,7 @@
   command_set.set(sandbox::syscall_broker::COMMAND_ACCESS);
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
   command_set.set(sandbox::syscall_broker::COMMAND_STAT);
-  if (IsChromeOS() &&
+  if (IsLinux() &&
       (options.use_amd_specific_policies ||
        options.use_intel_specific_policies ||
        options.use_nvidia_specific_policies ||
@@ -628,9 +659,9 @@
 
   AddVulkanICDPermissions(&permissions);
 
-  if (IsChromeOS()) {
+  if (IsLinux()) {
     // Permissions are additive, there can be multiple GPUs in the system.
-    AddStandardChromeOsPermissions(&permissions);
+    AddStandardLinuxPermissions(&permissions);
     if (UseV4L2Codec(options)) {
       AddV4L2GpuPermissions(&permissions, options);
     }
@@ -643,9 +674,11 @@
     }
     if (options.use_amd_specific_policies) {
       AddAmdGpuPermissions(&permissions);
+      AddLibGalliumLinuxPermissions(&permissions, options.driver_version);
     }
     if (options.use_intel_specific_policies) {
       AddIntelGpuPermissions(&permissions);
+      AddLibGalliumLinuxPermissions(&permissions, options.driver_version);
     }
     if (options.use_nvidia_specific_policies) {
       AddStandardGpuPermissions(&permissions);
@@ -678,7 +711,7 @@
   if (IsArchitectureArm()) {
     LoadArmGpuLibraries();
   }
-  if (IsChromeOS()) {
+  if (IsLinux()) {
     if (options.use_amd_specific_policies) {
       if (!LoadAmdGpuLibraries())
         return false;
--- a/content/gpu/gpu_main.cc
+++ b/content/gpu/gpu_main.cc
@@ -527,6 +527,7 @@
       else if (angle::IsNVIDIA(gpu.vendor_id))
         sandbox_options.use_nvidia_specific_policies = true;
     }
+    sandbox_options.driver_version = gpu_prefs.gallium_version;
   }
   sandbox_options.accelerated_video_decode_enabled =
       !gpu_prefs.disable_accelerated_video_decode;
--- a/content/public/browser/gpu_utils.cc
+++ b/content/public/browser/gpu_utils.cc
@@ -29,6 +29,10 @@
 #include "ui/gfx/switches.h"
 #include "ui/gl/gl_features.h"
 
+#if BUILDFLAG(IS_LINUX)
+#include "third_party/re2/src/re2/re2.h"
+#endif
+
 namespace {
 
 void KillGpuProcessImpl(content::GpuProcessHost* host) {
@@ -82,6 +86,25 @@
   gpu_preferences.gpu_sandbox_start_early =
       command_line->HasSwitch(switches::kGpuSandboxStartEarly);
 
+  gpu_preferences.gpu_sandbox_linux =
+#if BUILDFLAG(IS_LINUX)
+      command_line->HasSwitch("enable-gpu-sandbox-linux") &&
+      command_line->HasSwitch("ozone-platform") &&
+      command_line->GetSwitchValueASCII("ozone-platform") == "wayland";
+#else
+      false;
+#endif
+
+#if BUILDFLAG(IS_LINUX)
+  if (command_line->HasSwitch("libgallium-version")) {
+    const std::string libgalliumVersion =
+          command_line->GetSwitchValueASCII("libgallium-version");
+    // We may recieve untrusted input, so validate it matches a version format
+    if (RE2::FullMatch(libgalliumVersion, "[1-9][0-9]+\\.[0-9]\\.[0-9]"))
+      gpu_preferences.gallium_version = libgalliumVersion;
+  }
+#endif
+
   gpu_preferences.enable_vulkan_protected_memory =
       command_line->HasSwitch(switches::kEnableVulkanProtectedMemory);
   gpu_preferences.disable_vulkan_fallback_to_gl_for_testing =
--- a/gpu/config/gpu_preferences.h
+++ b/gpu/config/gpu_preferences.h
@@ -134,6 +134,12 @@
   // Starts the GPU sandbox before creating a GL context.
   bool gpu_sandbox_start_early = false;
 
+  // LibGallium library version for sandbox whitelist.
+  std::string gallium_version;
+
+  // Enable the GPU sandbox on Linux, implies gpu_sandbox_start_early
+  bool gpu_sandbox_linux = false;
+
   // Enables using CODECAPI_AVLowLatencyMode. Windows only.
   bool enable_low_latency_dxva = true;
 
--- a/gpu/ipc/common/gpu_preferences.mojom
+++ b/gpu/ipc/common/gpu_preferences.mojom
@@ -59,6 +59,8 @@
   bool gpu_startup_dialog;
   bool disable_gpu_watchdog;
   bool gpu_sandbox_start_early;
+  bool gpu_sandbox_linux;
+  string gallium_version;
 
   // TODO(http://crbug.com/676224) Support preprocessing of mojoms. Following
   // variables should be used on Windows only.
--- a/gpu/ipc/common/gpu_preferences_mojom_traits.h
+++ b/gpu/ipc/common/gpu_preferences_mojom_traits.h
@@ -221,6 +221,9 @@
     out->gpu_startup_dialog = prefs.gpu_startup_dialog();
     out->disable_gpu_watchdog = prefs.disable_gpu_watchdog();
     out->gpu_sandbox_start_early = prefs.gpu_sandbox_start_early();
+    out->gpu_sandbox_linux = prefs.gpu_sandbox_linux();
+    if (!prefs.ReadGalliumVersion(&out->gallium_version))
+      return false;
     out->enable_low_latency_dxva = prefs.enable_low_latency_dxva();
     out->enable_zero_copy_dxgi_video = prefs.enable_zero_copy_dxgi_video();
     out->enable_nv12_dxgi_video = prefs.enable_nv12_dxgi_video();
@@ -325,6 +328,12 @@
   static bool gpu_sandbox_start_early(const gpu::GpuPreferences& prefs) {
     return prefs.gpu_sandbox_start_early;
   }
+  static bool gpu_sandbox_linux(const gpu::GpuPreferences& prefs) {
+    return prefs.gpu_sandbox_linux;
+  }
+  static const std::string& gallium_version(const gpu::GpuPreferences& prefs) {
+    return prefs.gallium_version;
+  }
   static bool enable_low_latency_dxva(const gpu::GpuPreferences& prefs) {
     return prefs.enable_low_latency_dxva;
   }
--- a/gpu/ipc/service/gpu_init.cc
+++ b/gpu/ipc/service/gpu_init.cc
@@ -54,6 +54,10 @@
 #include <GLES2/gl2.h>
 #endif
 
+#if BUILDFLAG(IS_LINUX)
+#include "third_party/angle/src/gpu_info_util/SystemInfo.h"
+#endif
+
 #if BUILDFLAG(IS_OZONE)
 #if BUILDFLAG(ENABLE_VULKAN)
 #include "gpu/command_buffer/service/drm_modifiers_filter_vulkan.h"
@@ -354,6 +358,14 @@
   StopForceDiscreteGPU();
 }
 
+// TODO: Add the following
+//angle::IsNVIDIA(vendor_id)
+//angle::IsVirtIO(vendor_id)
+//angle::IsARM(vendor_id)
+bool IsGpuSandboxSupportedPlatform(uint32_t vendor_id) {
+  return angle::IsAMD(vendor_id) || angle::IsIntel(vendor_id);
+}
+
 bool GpuInit::InitializeAndStartSandbox(base::CommandLine* command_line,
                                         const GpuPreferences& gpu_preferences) {
   TRACE_EVENT("gpu,startup", "gpu::GpuInit::InitializeAndStartSandbox");
@@ -420,8 +432,21 @@
   enable_watchdog = false;
 #endif
 
+  bool gpu_sandbox_linux = gpu_preferences_.gpu_sandbox_linux;
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-  bool gpu_sandbox_start_early = gpu_preferences_.gpu_sandbox_start_early;
+  // Only enable on platforms where the sandbox works
+  if (gpu_sandbox_linux &&
+      IsGpuSandboxSupportedPlatform(gpu_info_.active_gpu().vendor_id)) {
+    for (const auto& gpu : gpu_info_.secondary_gpus) {
+      if (!IsGpuSandboxSupportedPlatform(gpu.vendor_id)) {
+        gpu_sandbox_linux = false;
+        break;
+      }
+    }
+  }
+  bool gpu_sandbox_start_early = gpu_preferences_.gpu_sandbox_start_early ||
+      // The sandbox does not work with Vulkan currently
+      (gpu_sandbox_linux && !features::IsUsingVulkan());
 #else   // !(BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS))
   // For some reasons MacOSX's VideoToolbox might crash when called after
   // initializing GL, see crbug.com/1047643 and crbug.com/871280. On other
@@ -462,7 +487,7 @@
   // On Chrome OS ARM Mali, GPU driver userspace creates threads when
   // initializing a GL context, so start the sandbox early.
   // TODO(zmo): Need to collect OS version before this.
-  if (gpu_preferences_.gpu_sandbox_start_early) {
+  if (gpu_sandbox_start_early) {
     gpu_info_.sandboxed = sandbox_helper_->EnsureSandboxInitialized(
         watchdog_thread_.get(), &gpu_info_, gpu_preferences_);
     attempted_startsandbox = true;
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
@@ -257,6 +257,20 @@
   return If((flags & ~kAllowedMask) == 0, Allow()).Else(CrashSIGSYS());
 }
 
+SANDBOX_EXPORT ResultExpr RestrictMmapFlagsNvidia() {
+#if defined(__x86_64__)
+  const uint64_t kNvidiaSpecificAllowedMask = MAP_EXECUTABLE | MAP_32BIT;
+#else
+  const uint64_t kNvidiaSpecificAllowedMask = MAP_EXECUTABLE;
+#endif
+  const uint64_t kAllowedMask = MAP_SHARED | MAP_PRIVATE | MAP_ANONYMOUS |
+                                MAP_STACK | MAP_NORESERVE | MAP_FIXED |
+                                MAP_DENYWRITE | MAP_LOCKED | MAP_DROPPABLE |
+                                kNvidiaSpecificAllowedMask;
+  const Arg<int> flags(3);
+  return If((flags & ~kAllowedMask) == 0, Allow()).Else(CrashSIGSYS());
+}
+
 SANDBOX_EXPORT ResultExpr RestrictMremapFlagsForODML() {
   // No flags are allowed.
   const uint64_t kAllowedMask = 0;
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h
@@ -40,6 +40,10 @@
 // Crash if any other flag is used.
 SANDBOX_EXPORT bpf_dsl::ResultExpr RestrictMmapFlags();
 
+// Nvidia requires a few more mmap calls in the gpu process.
+// Extra flags: MAP_32BIT | MAP_EXECUTABLE.
+SANDBOX_EXPORT bpf_dsl::ResultExpr RestrictMmapFlagsNvidia();
+
 // Restrict mmap(2) arguments to:
 // Allow: MAP_SHARED | MAP_PRIVATE | MAP_ANONYMOUS |
 // MAP_STACK | MAP_NORESERVE | MAP_FIXED | MAP_DENYWRITE.
--- a/sandbox/policy/linux/bpf_cros_nvidia_gpu_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_cros_nvidia_gpu_policy_linux.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "sandbox/policy/linux/bpf_cros_nvidia_gpu_policy_linux.h"
+#include "sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h"
 
 // Define these so that unistd.h pulls in needed symbols.
 #if !defined(__ARCH_WANT_SYSCALL_NO_AT) || \
@@ -29,7 +30,16 @@
 ResultExpr CrosNvidiaGpuProcessPolicy::EvaluateSyscall(int sysno) const {
   switch (sysno) {
     case __NR_sched_setscheduler:
+    case __NR_mprotect:
       return Allow();
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+    // (MAP_LOCKED | MAP_EXECUTABLE | MAP_32BIT)
+    case __NR_mmap:
+      return RestrictMmapFlagsNvidia();
+#endif
+    case __NR_memfd_create:
+      // TODO(crbug.com/442771181)
+      return RestrictMemfdCreateWithExecMappings();
     default:
       return GpuProcessPolicy::EvaluateSyscall(sysno);
   }
--- a/sandbox/policy/linux/bpf_gpu_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_gpu_policy_linux.cc
@@ -80,16 +80,6 @@
     case __NR_getdents64:
     case __NR_ioctl:
       return Allow();
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
-    // The Nvidia driver uses flags not in the baseline policy
-    // (MAP_LOCKED | MAP_EXECUTABLE | MAP_32BIT)
-    case __NR_mmap:
-      return Allow();
-#endif
-    // We also hit this on the linux_chromeos bot but don't yet know what
-    // weird flags were involved.
-    case __NR_mprotect:
-      return Allow();
     // XNNPACK needs mremap when building weight caches.
     case __NR_mremap:
       if (mremap_policy_ == MremapPolicy::kAllow) {
@@ -106,10 +96,6 @@
       return RestrictSchedTarget(GetPolicyPid(), sysno);
     case __NR_prlimit64:
       return RestrictPrlimit64(GetPolicyPid());
-    case __NR_memfd_create:
-      // TODO(crbug.com/442771181): Only nvidia drivers seems to use this. Maybe
-      // scope this allowance to only nvidia drivers.
-      return RestrictMemfdCreateWithExecMappings();
     default:
       break;
   }
--- a/sandbox/policy/linux/sandbox_seccomp_bpf_linux.cc
+++ b/sandbox/policy/linux/sandbox_seccomp_bpf_linux.cc
@@ -124,7 +124,7 @@
 std::unique_ptr<BPFBasePolicy> GetGpuProcessSandbox(
     const SandboxSeccompBPF::Options& options,
     MremapPolicy mremap_policy) {
-  if (IsChromeOS() || UseChromecastSandboxAllowlist()) {
+  if (true) {
     if (IsArchitectureArm()) {
       return std::make_unique<CrosArmGpuProcessPolicy>(
           mremap_policy, base::CommandLine::ForCurrentProcess()->HasSwitch(
--- a/sandbox/policy/linux/sandbox_seccomp_bpf_linux.h
+++ b/sandbox/policy/linux/sandbox_seccomp_bpf_linux.h
@@ -32,6 +32,7 @@
     // Options for GPU's PreSandboxHook.
     bool accelerated_video_decode_enabled = false;
     bool accelerated_video_encode_enabled = false;
+    std::string driver_version;
   };
 
   SandboxSeccompBPF() = delete;

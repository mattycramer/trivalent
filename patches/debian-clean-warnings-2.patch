Copyright 2024-2025 The Trivalent Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
---
--- a/components/assist_ranker/ranker_url_fetcher.cc
+++ b/components/assist_ranker/ranker_url_fetcher.cc
@@ -23,7 +23,7 @@
 namespace {
 
 // Retry parameter for fetching.
-const int kMaxRetry = 16;
+[[maybe_unused]] const int kMaxRetry = 16;
 
 }  // namespace
 
--- a/components/assist_ranker/ranker_url_fetcher.h
+++ b/components/assist_ranker/ranker_url_fetcher.h
@@ -73,7 +73,7 @@
   Callback callback_;
 
   // Counts how many times did it try to fetch the language list.
-  int retry_count_;
+  [[maybe_unused]] int retry_count_;
 
   // Max number how many times to retry on the server error
   int max_retry_on_5xx_;
--- a/components/autofill/core/browser/crowdsourcing/autofill_crowdsourcing_manager.cc
+++ b/components/autofill/core/browser/crowdsourcing/autofill_crowdsourcing_manager.cc
@@ -81,7 +81,7 @@
 constexpr size_t kAutofillCrowdsourcingManagerMaxFormCacheSize = 16;
 constexpr size_t kMaxFieldsPerQueryRequest = 100;
 
-constexpr base::TimeDelta kFetchTimeout(base::Seconds(10));
+[[maybe_unused]] constexpr base::TimeDelta kFetchTimeout(base::Seconds(10));
 
 constexpr net::BackoffEntry::Policy kAutofillBackoffPolicy = {
     // Number of initial errors (in sequence) to ignore before applying
@@ -113,7 +113,7 @@
     "https://content-autofill.9oo91eapis.qjz9zk/";
 
 // Header to get base64 encoded serialized proto from API for safety.
-constexpr char kGoogEncodeResponseIfExecutable[] =
+[[maybe_unused]] constexpr char kGoogEncodeResponseIfExecutable[] =
     "X-Goog-Encode-Response-If-Executable";
 
 // The default number of days after which to reset the registry of autofill
@@ -202,7 +202,7 @@
   return base::StrCat({"Autofill.", TypeToName(request_type), ".", suffix});
 }
 
-net::NetworkTrafficAnnotationTag GetNetworkTrafficAnnotation(
+[[maybe_unused]] net::NetworkTrafficAnnotationTag GetNetworkTrafficAnnotation(
     CrowdsourcingRequestType request_type) {
   switch (request_type) {
     case CrowdsourcingRequestType::kRequestQuery:
@@ -534,7 +534,7 @@
 }
 
 // Gets HTTP body payload for API POST request.
-std::optional<std::string> GetAPIBodyPayload(std::string payload,
+[[maybe_unused]] std::optional<std::string> GetAPIBodyPayload(std::string payload,
                                              CrowdsourcingRequestType type) {
   // Don't do anything for payloads not related to Query.
   if (type != CrowdsourcingRequestType::kRequestQuery) {
--- a/components/browsing_data/content/browsing_data_model.cc
+++ b/components/browsing_data/content/browsing_data_model.cc
@@ -472,7 +472,7 @@
   std::move(loaded_callback).Run();
 }
 
-void OnInterestGroupsLoaded(
+[[maybe_unused]] void OnInterestGroupsLoaded(
     BrowsingDataModel* model,
     base::OnceClosure loaded_callback,
     std::vector<content::InterestGroupManager::InterestGroupDataKey>
@@ -485,7 +485,7 @@
   std::move(loaded_callback).Run();
 }
 
-void OnAttributionReportingLoaded(
+[[maybe_unused]] void OnAttributionReportingLoaded(
     BrowsingDataModel* model,
     base::OnceClosure loaded_callback,
     std::set<content::AttributionDataModel::DataKey> attribution_reporting) {
@@ -497,7 +497,7 @@
   std::move(loaded_callback).Run();
 }
 
-void OnPrivateAggregationLoaded(
+[[maybe_unused]] void OnPrivateAggregationLoaded(
     BrowsingDataModel* model,
     base::OnceClosure loaded_callback,
     std::set<content::PrivateAggregationDataModel::DataKey>
--- a/components/omnibox/browser/autocomplete_controller.cc
+++ b/components/omnibox/browser/autocomplete_controller.cc
@@ -128,7 +128,7 @@
 
 constexpr bool is_android = !!BUILDFLAG(IS_ANDROID);
 
-void RecordMlScoreCoverage(size_t matches_with_non_null_scores,
+[[maybe_unused]] void RecordMlScoreCoverage(size_t matches_with_non_null_scores,
                            size_t total_scored_matches) {
   int percent_score_coverage =
       matches_with_non_null_scores * 100 / total_scored_matches;
@@ -139,7 +139,7 @@
 
 // Records the coverage (i.e. null vs non-null values) for each of the
 // `scoring_signals` associated with matches generated by the given `provider`.
-void RecordScoringSignalCoverageForProvider(
+[[maybe_unused]] void RecordScoringSignalCoverageForProvider(
     const ScoringSignals& scoring_signals,
     const AutocompleteProvider* provider) {
   // Keep consistent:
@@ -226,13 +226,13 @@
   }
 }
 
-void RecordMlScoringElapsedTime(base::TimeDelta elapsed) {
+[[maybe_unused]] void RecordMlScoringElapsedTime(base::TimeDelta elapsed) {
   UMA_HISTOGRAM_CUSTOM_MICROSECONDS_TIMES(
       "Omnibox.URLScoringModelExecuted.ElapsedTime", elapsed,
       base::Microseconds(1), base::Milliseconds(3), 100);
 }
 
-void RecordTotalMatchesScored(size_t num_scored) {
+[[maybe_unused]] void RecordTotalMatchesScored(size_t num_scored) {
   base::UmaHistogramCounts1000("Omnibox.URLScoringModelExecuted.Matches",
                                num_scored);
 }
--- a/components/security_interstitials/content/ssl_blocking_page_base.cc
+++ b/components/security_interstitials/content/ssl_blocking_page_base.cc
@@ -14,7 +14,7 @@
 #include "ui/base/l10n/l10n_util.h"
 
 namespace {
-PrefService* GetPrefs(content::WebContents* web_contents) {
+[[maybe_unused]] PrefService* GetPrefs(content::WebContents* web_contents) {
   return user_prefs::UserPrefs::Get(web_contents->GetBrowserContext());
 }
 }  // namespace
--- a/chrome/common/google_url_loader_throttle.cc
+++ b/chrome/common/google_url_loader_throttle.cc
@@ -68,7 +68,7 @@
   return RequestBoundSessionStatus::kCoveredWithMissingCookie;
 }
 
-bool IsCoveredRequestBoundSessionStatus(RequestBoundSessionStatus status) {
+[[maybe_unused]] bool IsCoveredRequestBoundSessionStatus(RequestBoundSessionStatus status) {
   switch (status) {
     case RequestBoundSessionStatus::kNotCovered:
       return false;
--- a/chrome/common/google_url_loader_throttle.h
+++ b/chrome/common/google_url_loader_throttle.h
@@ -88,7 +88,7 @@
       bound_session_request_throttled_handler_;
   std::optional<base::TimeTicks> bound_session_request_throttled_start_time_;
   bool is_main_frame_navigation_ = false;
-  bool sends_cookies_ = false;
+  [[maybe_unused]] bool sends_cookies_ = false;
   // `true` if at least one URL in the redirect chain was affected.
   bool is_covered_by_bound_session_ = false;
   bool is_deferred_for_bound_session_ = false;
--- a/extensions/browser/updater/update_service.cc
+++ b/extensions/browser/updater/update_service.cc
@@ -107,7 +107,7 @@
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
   // Custom attributes can only be sent for NOT_UPDATED/UPDATE_FOUND events.
-  bool should_perform_action_on_omaha_attributes = false;
+  [[maybe_unused]] bool should_perform_action_on_omaha_attributes = false;
 
   switch (item.state) {
     case update_client::ComponentState::kUpToDate:
--- a/chrome/browser/media/router/discovery/mdns/dns_sd_device_lister.cc
+++ b/chrome/browser/media/router/discovery/mdns/dns_sd_device_lister.cc
@@ -12,7 +12,7 @@
 
 namespace {
 
-void FillServiceInfo(const ServiceDescription& service_description,
+[[maybe_unused]] void FillServiceInfo(const ServiceDescription& service_description,
                      DnsSdService* service) {
   service->service_name = service_description.service_name;
   service->service_host_port = service_description.address;
--- a/ui/linux/linux_ui_factory.cc
+++ b/ui/linux/linux_ui_factory.cc
@@ -195,27 +195,6 @@
 
 SystemTheme GetDefaultSystemTheme() {
   return SystemTheme::kDefault;
-  std::unique_ptr<base::Environment> env = base::Environment::Create();
-
-  switch (base::nix::GetDesktopEnvironment(env.get())) {
-    case base::nix::DESKTOP_ENVIRONMENT_CINNAMON:
-    case base::nix::DESKTOP_ENVIRONMENT_GNOME:
-    case base::nix::DESKTOP_ENVIRONMENT_PANTHEON:
-    case base::nix::DESKTOP_ENVIRONMENT_UNITY:
-    case base::nix::DESKTOP_ENVIRONMENT_XFCE:
-    case base::nix::DESKTOP_ENVIRONMENT_COSMIC:
-      return SystemTheme::kGtk;
-    case base::nix::DESKTOP_ENVIRONMENT_KDE3:
-    case base::nix::DESKTOP_ENVIRONMENT_KDE4:
-    case base::nix::DESKTOP_ENVIRONMENT_KDE5:
-    case base::nix::DESKTOP_ENVIRONMENT_KDE6:
-    case base::nix::DESKTOP_ENVIRONMENT_UKUI:
-    case base::nix::DESKTOP_ENVIRONMENT_DEEPIN:
-    case base::nix::DESKTOP_ENVIRONMENT_LXQT:
-      return SystemTheme::kQt;
-    case base::nix::DESKTOP_ENVIRONMENT_OTHER:
-      return SystemTheme::kDefault;
-  }
 }
 
 }  // namespace ui
--- a/chrome/browser/safe_browsing/advanced_protection_status_manager_desktop.cc
+++ b/chrome/browser/safe_browsing/advanced_protection_status_manager_desktop.cc
@@ -71,17 +71,11 @@
   RecordStartupUma(is_under_advanced_protection_);
   NotifyObserversStatusChanged();
 
-  if (false) {
-    if (is_under_advanced_protection_) {
-      ScheduleNextRefresh();
-    }
-  } else {
-    // User's advanced protection status is unknown, refresh in
-    // |minimum_delay_|.
-    timer_.Start(FROM_HERE, minimum_delay_, this,
-                 &AdvancedProtectionStatusManagerDesktop::
-                     RefreshAdvancedProtectionStatus);
-  }
+  // User's advanced protection status is unknown, refresh in
+  // |minimum_delay_|.
+  timer_.Start(FROM_HERE, minimum_delay_, this,
+               &AdvancedProtectionStatusManagerDesktop::
+                   RefreshAdvancedProtectionStatus);
 }
 
 void AdvancedProtectionStatusManagerDesktop::Shutdown() {
--- a/chrome/browser/search/search.cc
+++ b/chrome/browser/search/search.cc
@@ -95,7 +95,7 @@
   NEW_TAB_URL_MAX
 };
 
-const TemplateURL* GetDefaultSearchProviderTemplateURL(Profile* profile) {
+[[maybe_unused]] const TemplateURL* GetDefaultSearchProviderTemplateURL(Profile* profile) {
   if (profile) {
     TemplateURLService* template_url_service =
         TemplateURLServiceFactory::GetForProfile(profile);
@@ -142,7 +142,7 @@
                                     IsMatchingServiceWorker(url, new_tab_url));
 }
 
-bool IsURLAllowedForSupervisedUser(const GURL& url, Profile& profile) {
+[[maybe_unused]] bool IsURLAllowedForSupervisedUser(const GURL& url, Profile& profile) {
   if (!profile.IsChild()) {
     return true;
   }
--- a/components/blocked_content/popup_blocker.cc
+++ b/components/blocked_content/popup_blocker.cc
@@ -22,7 +22,7 @@
 namespace blocked_content {
 namespace {
 
-content::Page& GetSourcePageForPopup(
+[[maybe_unused]] content::Page& GetSourcePageForPopup(
     const content::OpenURLParams* open_url_params,
     content::WebContents* web_contents) {
   if (open_url_params) {
--- a/components/themes/ntp_background_service.cc
+++ b/components/themes/ntp_background_service.cc
@@ -91,9 +91,8 @@
 
 void NtpBackgroundService::FetchCollectionInfo(
     const std::string& filtering_label) {
-  // If a request is currently in progress, drop the new request.
-    return;
-  collection_error_info_.ClearError();
+  return;
+}
 
   net::NetworkTrafficAnnotationTag traffic_annotation =
       net::DefineNetworkTrafficAnnotation("backdrop_collection_names_download",
--- a/chrome/browser/permissions/permission_revocation_request.cc
+++ b/chrome/browser/permissions/permission_revocation_request.cc
@@ -83,7 +83,7 @@
       base::Value(std::move(dict)));
 }
 
-void SetOriginStatus(Profile* profile,
+[[maybe_unused]] void SetOriginStatus(Profile* profile,
                      const GURL& origin,
                      const OriginStatus& status) {
   SetOriginStatusFromHostContentSettingsMap(
--- a/chrome/browser/extensions/extension_safety_check_utils.cc
+++ b/chrome/browser/extensions/extension_safety_check_utils.cc
@@ -108,7 +108,7 @@
 
 // Returns true if the Safety Check should display a no off-store extension
 // warning.
-bool SafetyCheckShouldShowOffstoreExtension(
+[[maybe_unused]] bool SafetyCheckShouldShowOffstoreExtension(
     const Extension& extension,
     Profile* profile,
     const std::optional<CWSInfoService::CWSInfo>& cws_info) {
--- a/chrome/browser/extensions/webstore_installer.cc
+++ b/chrome/browser/extensions/webstore_installer.cc
@@ -104,12 +104,12 @@
 
 // Folder for downloading crx files from the webstore. This is used so that the
 // crx files don't go via the usual downloads folder.
-const base::FilePath::CharType kWebstoreDownloadFolder[] =
+[[maybe_unused]] const base::FilePath::CharType kWebstoreDownloadFolder[] =
     FILE_PATH_LITERAL("Webstore Downloads");
 
 base::FilePath* g_download_directory_for_tests = nullptr;
 
-base::FilePath GetDownloadFilePath(const base::FilePath& download_directory,
+[[maybe_unused]] base::FilePath GetDownloadFilePath(const base::FilePath& download_directory,
                                    const extensions::ExtensionId& id) {
   // Ensure the download directory exists. TODO(asargent) - make this use
   // common code from the downloads system.
@@ -131,7 +131,7 @@
   return base::GetUniquePath(file);
 }
 
-void MaybeAppendAuthUserParameter(const std::string& authuser, GURL* url) {
+[[maybe_unused]] void MaybeAppendAuthUserParameter(const std::string& authuser, GURL* url) {
   if (authuser.empty())
     return;
   std::string old_query = url->GetQuery();
